<!--
DevDOCS

Bulma Quick Start:
	- https://bulma.io/documentation/overview/start/
-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>AEC 2018/2</title>
    <link rel="stylesheet" href="/shared/bulma.min.css">
    <script defer src="/shared/fontawesome.js"></script>
    <style type="text/css">
		.main {
			margin: 0 auto;
			max-width: 720px;
		}

    	/*source: https://stackoverflow.com/a/9753612*/
		.tpre {
			font-family: monospace;
    		white-space: pre;
		}
    </style>
  </head>
  <body>
  <div>
    <div id="pagetop" class="container main">
      <h1 class="title">
        <center>Autômatos Resumo</center>
      </h1>
      <div class="content" style="margin-top: 1em;">
        <div id="sec05">
          <div id="pwatoc"><ul></ul></div>
        </div>
        <div id="sec04" class="sec">
          
        </div>
        <div id="sec03" class="sec">
          <center id="sec-lteo"><h4>Lista de Teoremas</h4></center>
          <table class="table">
            <thead><tr><td>Nº</td><td>Página</td><td>Descrição</td><td>Comentário</td></tr></thead>
            <tbody>
              <tr><td>1.25</td><td>45</td><td>The class of regular languages is closed under the union operation.</td><td></td></tr>
              <tr><td>1.26</td><td>47</td><td>The class of regular languages is closed under the concatenation operation</td><td></td></tr>
              <tr><td>1.39</td><td>55</td><td>Every nondeterministic finite automaton has an equivalent deterministic finite automaton.</td><td></td></tr>
              <tr><td>1.40</td><td>56</td><td>(Corolário) A language is regular if and only if some nondeterministic finite automaton recognizes it.</td><td></td></tr>
              <tr><td>1.45</td><td>58</td><td>The class of regular languages is closed under the union operation.</td><td></td></tr>
              <tr><td>1.47</td><td>60</td><td>The class of regular languages is closed under the concatenation operation.</td><td>Provado utilizando autômatos não determinísticos (AFNs)</td></tr>
              <tr><td>1.49</td><td>62</td><td>The class of regular languages is closed under the star operation.</td><td>
                <p>Prova por construção. Assume-se que existe uma máquina \(N_1\) que aceita a linguagem \(A_1\), e usando ela como base, será construída uma nova máquina \(N\) tal que aceita \(A_1*\).</p><p>As modificações são simples: todos os estados de aceitação de \(N_1\) passam a ter uma transição \(\epsilon\) para o estado inicial de \(N_1\). E como a operação estrela gera uma linguagem sempre contendo \(\epsilon\) (\(\epsilon\ \in A_1\)), então é necessário criar um novo estado inicial.</p></td>
              </tr>
              <!-- A language is regular if and only if some regular expression describes it -->
              <tr><td>1.54,1.60</td><td>66,69-77</td><td>(Lemma) A language is regular if and only if some regular expression describes it</td><td>O temorema é provado em duas direções. Na ida assume-se que existe uma DFA que aceite a linguagem regular, transforma em GNFA, e por fim em expressão regular. Na volta ele mostra cada uma dos seis casos descritas na definição de uma expressão regular a NFA equivalente.<br>Na volta, é mostrado que cada uma das <a href="#def-152">formas básicas</a> de expressão regular (1,2,3) possuem uma AFN equivalente. As três últimas (4,5,6) foram provadas anteriormente para as AFNs nos teoremas</td></tr>
              <tr><td>1.70</td><td>78</td><td>If A is a regular language, then there is a number \(p\) (the pumping length) where if \(s\) is any string in \(A\) of length at least \(p\), then \(s\) may be divided into three pieces, \(s = xyz\), satisfying the following conditions: <ol><li>for each \(i \geq 0, xy^iz \in A,\)</li><li>\(|y| \gt 0\), and</li><li>\(|xy| \leq p\)</li></ol></td><td></td></tr>
              <tr><td>2.9</td><td>109</td><td>Any context-free language is generated by a context-free grammar in Chomsky normal form.</td><td></td></tr>
              <tr><td></td><td></td><td></td><td></td></tr>
            </tbody>
          </table>
        </div>
        <div id="sec02" class="sec">
          <center id="sec-defs"><h4>Definições</h4></center>
          <table class="table">
            <thead>
              <tr><td>Nº</td><td>Página</td><td>Descrição</td><td>Comentário</td></tr>
            </thead>
            <tbody>
              <tr><td>1.5</td><td>35</td><td>A finite automaton is a 5-tuple \((Q,\Sigma, \delta, q_0, F)\), where
                <ol>
                  <li>\(Q\) is a finite set called the <strong>states</strong>,</li>
                  <li>\(\Sigma\) is a finite set called the <strong>alphabet</strong>,</li>
                  <li>\(\sigma : Q \times \Sigma \to Q\) is the transition function<sup class="fn">Refer back to page 7 if you are uncertain about the meaning of \(\sigma : Q \times \Sigma \to Q\).</sup>,</li>
                  <li>\(q_0 \in Q\) is the <strong>start state</strong>, and</li>
                  <li>\(F \subset Q \) is the set of <strong>accept states</strong><sup class="fn">Accept states sometimes are called <strong>final states</strong></sup></li>
                </ol>
              </td><td></td></tr>
              <tr><td>1.16</td><td>40</td><td>A language is called a <i><strong>regular language</strong></i> if some finite automaton recognizes it.</td><td></td></tr>
              <tr><td>1.23</td><td>44</td><td>Let \(A\) and \(B\) be languages. We define the regular operations union, concatenation, and star as follows:
              <ol>
                <li><strong>Union: </strong> \(A \cup B = \{x | x \in A \text{ or } x \in B \}\)</li>
                <li><strong>Concatenation: </strong> \(A \circ B = \{ xy | x \in A \text{ and } y \in B \}\)</li>
                <li><strong>Star: </strong> \(A^* = \{ x_1x_2...x_k | k \geq 0 \text{ and } x_i \in A \}\)</li>
              </ol>
              </td><td></td></tr>
              <tr><td>1.37</td><td>53</td><td>A <i><strong>nondeterministic finite automaton</strong></i> is a 5-tuple \((Q, \Sigma, \sigma, q_0, F)\), where
                <ol>
                  <li>\(Q\) is a finite set of states,</li>
                  <li>\(\Sigma\) is a finite alphabet,</li>
                  <li>\(\sigma : Q \times \Sigma_\epsilon \to P(Q)\) is the transition function,</li>
                  <li>\(q_0 \in Q\) is the start state, and</li>
                  <li>\(F \subseteq Q\) is the set of accept states.</li>
                </ol>
              </td><td></td></tr>
              <tr><td><span id="def-152">1.52</span></td><td>64</td><td>Say that <i>R</i> is a regular expression if <i>R</i> is
                <ol>
                  <li><i>a</i> for some <i>a</i> in the alphabet \(\Sigma\),</li>
                  <li>\(\epsilon\),</li>
                  <li>\(\emptyset\),</li>
                  <li>\((R1 \cup R2)\), where R<sub>1</sub> and R<sub>2</sub> are regular expressions,</li>
                  <li>\((R1 \circ R2)\), where R<sub>1</sub> and R<sub>2</sub> are regular expressions, or</li>
                  <li>\((R^*)\) , where R<sub>1</sub> is a regular expression.</li>
                </ol>
                <p>In items 1 and 2, the regular expressions <i>a</i> and  represent the languages \(\{a\}\) and \(\{\epsilon\}\), respectively. In item 3, the regular expression \(\emptyset\) represents the empty language. In items 4, 5, and 6, the expressions represent the languages obtained by taking the union or concatenation of the languages R<sub>1</sub> and R<sub>2</sub>, or the star of the language R<sub>1</sub>, respectively.</p>
              </td><td></td></tr>
              <tr><td>1.64</td><td>73</td><td>A <i><strong>generalized nondeterministic finite automaton</strong></i> is a 5-tuple, \((Q,\Sigma, \delta, qstart, qaccept)\), where
                <ol>
                  <li>\(Q\) is the finite set of states,</li>
                  <li>\(\Sigma\) is the input alphabet,</li>
                  <li>\(\delta: (Q - \{q_{accept}\} \times (Q - \{q_{start}\}) \to R\) is the transition function,</li>
                  <li>\(q_{start}\) is the start state, and </li>
                  <li>\(q_{accept}\) is the accept state.</li>
                </ol>
              </td><td></td></tr>
              <tr><td>1.70</td><td>78</td><td><i><strong>Pumping lemma</strong></i> If <i>A</i> is a regular language, then there is a number <i>p</i> (the pumping length) where if <i>s</i> is any string in <i>A</i> of length at least <i>p</i>, then <i>s</i> may be divided into three pieces, \(s = xyz\), satisfying the following conditions:
                <ol>
                  <li>for each \(i \geq 0\), \(xy^iz \in A\), </li>
                  <li>\(|y| \gt 0\), and</li>
                  <li>\(|xy| \leq p\)</li>
                </ol>
              </td><td></td></tr>
              <tr><td>2.2</td><td>104</td><td>A <i><strong>context-free grammar</strong></i> is a 4-tuple \((V, \Sigma, R, S)\), where
                <ol>
                  <li>\(V\) is a finite set called the <strong>variables</strong>,</li>
                  <li>\(\Sigma\) is a finite set, disjoint from \(V\), called the <strong>terminals</strong>,</li>
                  <li>\(R\) is a finite set of <strong>rules</strong>, with each rule being a variable and a string of variables and terminals, and</li>
                  <li>\(S \in V\) is the start variable.</li>
                </ol>
              </td><td></td></tr>
              <tr><td>2.7</td><td>108</td><td>A string \(w\) is derived <i><strong>ambiguously</strong></i> in context-free grammar \(G\) if it has two or more different leftmost derivations. Grammar \(G\) is ambiguous if it generates some string ambiguously.</td><td></td></tr>
              <tr><td>2.8</td><td>109</td><td>A context-free grammar is in <strong>Chomsky normal form</strong> if every rule is of the form<br><center>\(A \to BC\)<br>\(A \to a\)</center><br>where a is any terminal and A, B, and C are any variables—except that B and C may not be the start variable. In addition, we permit the rule \(S \to \epsilon\), where S is the start variable.</td><td></td></tr>
              <tr><td></td><td></td><td></td><td></td></tr>
            </tbody>
          </table>
        </div>
        <div id="sec01" class="sec">
          <center id="sec-quest"><h4>Questionário</h4></center>
          <table class="table">
            <thead><tr><td>Página</td><td>Questão</td><td>Trivia</td><td>Comentário</td></tr></thead>
            <tbody>
              <tr><td>62</td><td>Seja \(L_1\) uma linguagem regular e \(M_1\) uma máquina que a aceite. Podemos construir \(M_2\) tal que aceite \(L_1^*\) da seguinte forma: fazendo os estados de aceitação apontarem para o estado inicial via transições \(\epsilon\) e marcar o estado inicial como o de aceitação conforme a figura abaixo.</td><td>F</td><td>Fazer com que o estado de aceitação original \(q_0 \in F\) traz problemas discutidos no exercício 1.15</td></tr>
              <tr><td>65</td><td>Os parêntheis não podem ser omitidos na definição de uma expressão regular.</td><td>F</td><td>Podem ser omitidos seguindo a ordem de precedência</td></tr>
              <tr><td>70</td><td>Em uma GNFA o estado de aceitação não pode ser também o estado inicial</td><td>V</td><td>Isto quebra uma das 3 restrições impostas para uma NFA ser uma GNFA.</td></tr>
              <tr><td></td><td></td><td></td><td></td></tr>
            </tbody>
          </table>
        </div>
        <div id="sec00" class="sec">
          <center id="sec-info"><h4>Observações</h4></center>
          <ul>
            <li>Livro:
              <ul>
                <li>Nome: Introduction to the Theory of Computation</li>
                <li>Autor: Michael Sipser</li>
                <li>Edição: 3ª</li>
                <li>ISBN-10: 113318779X</li>
                <li>ISBN-13: 978-1133187790</li>
                <li>Links: <a href="https://www.amazon.com/Introduction-Theory-Computation-Michael-Sipser/dp/113318779X">Amazon</a></li>
              </ul>
            </li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <script src="/shared/jquery-3.3.1.min.js"></script>
  <script src="/shared/footnotes.js"></script>
  <script src="/shared/toc.js"></script>
  <!-- original src: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML -->
  <script src="/shared/mathjax/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
  <script>
  </script>
  </body>
</html>